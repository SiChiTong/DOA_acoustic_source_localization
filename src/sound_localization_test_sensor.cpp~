#include <ros/ros.h>
#include <ros/package.h>
#include <tf/transform_listener.h>
#include <visualization_msgs/Marker.h>
#include "tf_conversions/tf_eigen.h"

#include <Eigen/Dense>
#include <Eigen/Geometry>
#include <Eigen/StdVector>
#include <eigen_conversions/eigen_msg.h>

#include <hark_msgs/HarkSource.h>
#include <std_msgs/String.h>

#include <string>
#include <iostream>
#include <fstream>
#include <math.h>
#include <limits>

using namespace Eigen;
using namespace std;

bool print = true;
bool first_time = true;
int count_data = 0;

ofstream results("/tmp/test.txt", ofstream::out);

ros::NodeHandle * node_handler = 0;
ros::Rate * loop_rate;

template<typename T>
std::string to_string(const T & Value)
{
	std::ostringstream oss;
	oss << Value;
	return oss.str();
}

void harkCallback(const hark_msgs::HarkSource & msg)
{
	bool found = false;
	tf::StampedTransform tmp_transform;
	tf::TransformListener listener;
	while (!found) {
		try {
			ros::Time now = ros::Time::now();
			string world = "world";
			string tmp_source_position_3D_topic = "/checkerboard_cb_/kinect1_rgb";
			listener.waitForTransform(tmp_source_position_3D_topic, world, now, ros::Duration(1.0));
			listener.lookupTransform(tmp_source_position_3D_topic, world, ros::Time(0), tmp_transform);
			found = true;
		} catch (tf::TransformException ex) {
			ROS_ERROR("%s", ex.what());
		}
	}

	Eigen::Affine3d tmp_eigen_transform;
	tf::transformTFToEigen(tmp_transform, tmp_eigen_transform);

	if(print){
		/*cout << msg.src[0].azimuth/180.0 * M_PI << endl;	
		cout << tmp_eigen_transform.translation() << endl;		
		cout << tmp_eigen_transform.rotation().matrix() << endl << endl;	*/
		cout << "Data number: " << _data++ << endl;

		if(first_time){
			first_time = false;
			results << "A = [[";
			results.close();
		}
		results.open ("/tmp/test.txt", std::ofstream::out | std::ofstream::app);
		results << msg.src[0].azimuth/180.0 * M_PI << ", ";
		
		results << tmp_eigen_transform.translation().x() << ", ";
		results << tmp_eigen_transform.translation().y() << ", ";
		results << tmp_eigen_transform.translation().z() << ", ";
		
		for (int i = 0; i < 3; i++){
			for (int j = 0; j < 3; j++){
				if(i == 2 and j == 2)
					results << tmp_eigen_transform.rotation().matrix()(i,j);
				else
					results << tmp_eigen_transform.rotation().matrix()(i,j) << ", ";	
			}
		}
		results << "];\n[";
		results.close();
	}
}

void actionCallback(const std_msgs::String::ConstPtr & msg)
{
	cout << msg->data << endl;
	if (msg->data == "start"){
		print = true;
		cout << "start"  << endl;
	}else if (msg->data == "stop"){
		print = false;
		cout << "stop" << endl;
	}
}

int main(int argc, char **argv) {
	ros::init(argc, argv, "sound_localization_test_sensor");
	ros::NodeHandle nh;
	ros::NodeHandle input_nh("~");
	node_handler = &nh;
	ros::Rate lr(10);
	loop_rate = &lr;

	string tmp_source_audio_direction_topic;
	input_nh.getParam("source_audio_direction_topic_1", tmp_source_audio_direction_topic);

	ros::Subscriber sub = nh.subscribe(tmp_source_audio_direction_topic, 100, harkCallback);

	ros::Subscriber action = input_nh.subscribe<std_msgs::String>("action", 1, &actionCallback);

	while (ros::ok()) {
		ros::spinOnce();			
		loop_rate->sleep();
	}
}
